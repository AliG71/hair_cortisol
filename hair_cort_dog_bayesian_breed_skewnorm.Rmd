---
title: "hair_cortisol_dog_combined_breed"
author: "Alex German"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Check working directory
```{r}
getwd()
```





# Load packages
```{r}
library(readxl)
library(psych)
library(dlookr)
library(vtable)
library(dplyr)
library(reshape)
library(ggplot2)

library(brms)
library(rethinking)
library(loo)
library(priorsense)
library(tidyverse)
library(vioplot)
library(bayesplot)
library(bayestestR)
```


# Load data
```{r}
df <- read_xlsx("hair_cort_dog_all.xlsx", col_types = c("text", "text",  
                               "text", "text", "text", "text",
                               "text", "numeric","text", "skip",
                               "numeric", "skip", "skip", 
                               "numeric", "skip"))
df <- as.data.frame(df)
```


# INITIAL DATA PLOTTING AND EXPLORATION

## Check characteristics of df
```{r}
dim(df) # will tell you how many rows and columns the dataset has
class(df) # will tell you what data structure has the dataset been assigned
```


## Explore the dataset to understand its structure.
```{r}
head(df)
```


# 1.  Get summary stats for numeric data
```{r}
numeric_df <- Filter(is.numeric, df)
describe(numeric_df) # the describe function in psych provides summary stats
```



# 2. Check normality of all numeric variables
## a. graphical assessment
```{r}
plot_normality(numeric_df)
```


## b. shapiro-wilk test
```{r}
apply(numeric_df, 2, shapiro.test)
```


## c. repeat Q-Q plots with transformed data
### i. log(cortisol)
```{r}
qqnorm(df$cortisol)
qqline(df$cortisol, col = "red")
qqnorm(log(df$cortisol))
qqline(log(df$cortisol), col = "red")
```

### ii Shapiro test for log cortisol
```{r}
shapiro.test(log(df$cortisol))
```






# 3. Check data numerically
```{r}
summary(df$cortisol)
summary(log(df$cortisol))
```


## a. log-transform cortisol
```{r}
df$lgCort <- log(df$cortisol)
summary(df$lgCort)
```

### i. visualise
```{r}
hist(df$lgCort)
```


## b. Create simple category name for breed and convert to factor
```{r}
df$breed <- df$breed_group
df$breed <- factor(df$breed, levels = c("mix", "ckcs", "pug", "ret", "other"))
head(df$breed)
```



# 4. Generate data summary
```{r}
sumtable(df)
```



# 5. Visualise associations
## a. between lgCortisol and breed with violin plot
```{r}
par(mfrow = c(1,1))
vioplot(lgCort ~ breed, col = "firebrick",
        data = df)
```


## b. between lgCortisol and breed with stripchart
```{r}
stripchart(lgCort ~ breed, vertical = TRUE, method = "jitter",
           col = "steelblue3", data = df, pch = 20)

```




# STANDARDISE DATA FOR MODELLING


## 1. Standardise cortisol
```{r}
df$slgCort <- standardize(df$lgC)
summary(df$slgCort)
```

### a. visualise standardised lgCort
```{r}
hist(df$slgCort)
```


## 2. create dataset only containing complete data
```{r}
df2 <- na.omit(df)
```



# MODEL FOR THE EFFECT OF BREED ON HAIR CORTISOL



##  1. Model code
model <- brm(slgCort ~ breed +  (1 | visit),
                   family = skew_normal(),
                   data = df2)



## 2. Check what priors need to be set
```{r}
default_prior(slgCort ~ breed + (1 | visit),
                   family = skew_normal(),
                   data = df2)
```

### Published information about associations with hair cortisol
No published data about effects on breed, but this is plausible
However, unclear as to which breeds will differ and which way.
Therefore, use a regularising prior but keep it neutral and broad.


## 3. Set priors
```{r}

# Set individual priors
prior_int <- set_prior("normal(0, 0.5)", class = "Intercept")
prior_sig <- set_prior("exponential(1)", class = "sigma")
prior_b <- set_prior("normal(0, 1)", class = "b")
prior_sd <- set_prior("normal(0, 1)", class = "sd")
prior_alpha <- set_prior("normal(4, 8)", class = "alpha")

# Combine priors into list
priors <- c(prior_int, prior_sig, prior_b, prior_sd, prior_alpha)

```




# 4. Plot priors
## a. Prior for intercept
```{r}
x <- seq(-3, 3, length.out = 100)
y <- dnorm(x, mean = 0, sd = 1)
plot(y ~ x, type = "l")
```


## b. Prior for sigma
```{r}
x <- seq(0, 3, length.out = 100)
y <- dexp(x, rate = 0.5)
plot(y ~ x, type = "l")
```


## b.ii. deciding on alpha for skew normal distribution
Based on distribution of log normal hair cortisol, expect things to be skewed to the right.  Try different levels of alpha for skew normal.  
```{r}
x <- seq(-3, 5, length.out = 100)
y <- dskew_normal(x, mu = 0, sigma = 1, alpha = 4)
plot(y ~ x, type = "l")
```

So, expect alpha to be positive... perhaps 4, but keep sd broad to allow some flexibility




## biii. Prior for visit sd
```{r}
x <- seq(0, 5, length.out = 100)
y <- dnorm(x, mean = 0, sd = 2)
plot(y ~ x, type = "l")
```




## c. Prior for breed
```{r}
x <- seq(-3, 3, length.out = 100)
y <- dnorm(x, mean = 0, sd = 1.0)
plot(y ~ x, type = "l")
```




## 5.  Run model
Increased adapt_delta >0.8 (0.9 here), as had divergent transitions
```{r}
set.seed(666)
model <- brm(slgCort ~ breed + (1 | visit),
                   family = skew_normal(),
                   data = df,
                   prior = priors,
                   control=list(adapt_delta=0.99999999, stepsize = 0.001, max_treedepth = 15),
                   iter = 8000, warmup = 2000,
                   cores = 4,
                   save_pars = save_pars(all =TRUE),
                   sample_prior = TRUE)
```


## 6. Get summary of model
```{r}
summary(model)
```


## 7. MCMC diagnostics
```{r}
plot(model)
```
Looking for hairy caterpillars


## b. try a trank plot as well
```{r}
mcmc_plot(model, type = 'rank_overlay')
```



## 8. Calculate 95% HPDI for breed
Usually better than the compatability intervals given in the summary
### a. ckcs
```{r}
draws <- as.matrix(model)
HPDI(draws[,2], 0.97) # 2nd column is draws for ckcs
```

### b. pug
```{r}
draws <- as.matrix(model)
HPDI(draws[,3], 0.97) # 3rd column is draws for pug
```


### b. ret
```{r}
draws <- as.matrix(model)
HPDI(draws[,4], 0.97) # 4th column is draws for ret
```


### b. other
```{r}
draws <- as.matrix(model)
HPDI(draws[,5], 0.97) # 5th column is draws for other
```




# 9. Calculate R2 for model
```{r}
bayes_R2(model, probs = c(0.015, 0.5, 0.985)) # 0.015, 0.5, 0.985 are the quantiles
loo_R2(model, probs = c(0.015, 0.5, 0.985)) # 0.015, 0.5, 0.985 are the quantiles
```





# CHECKS ON MODEL

## 1. Basic check of simulations based on posterior distribution, versus the real data distribution
checks whether actual data is similar to simulated data.
```{r}
pp_check(model, ndraws = 100) 
```



## 2 Check some individual draws versus observed using pp_check
```{r}
par(mfrow = c(1,1))
pp_check(model, type = "hist", ndraws = 11, binwidth = 0.25) # separate histograms of 11 MCMC draws vs actual data
```



## 3. Other pp_check graphs
```{r}
pp_check(model, type = "error_hist", ndraws = 11) # separate histograms of errors for 11 draws
pp_check(model, type = "scatter_avg", ndraws = 100) # scatter plot
pp_check(model, type = "stat_2d") #  scatterplot of joint posteriors
# PPC functions for predictive checks based on (approximate) leave-one-out (LOO) cross-validation
pp_check(model, type = "loo_pit_overlay", ndraws = 1000) 
```


## 4. Error scatter average  plot (recommended by Buerkner)
```{r}
pp_check(model, type = "error_scatter_avg")
```



## 5. Pairs plot
```{r}
pairs(model)
```


# PSIS LOO-CV to check model performance
```{r}
loo_model <- loo(model, moment_match = TRUE)
loo_model
```



# AUTOMATED PRIOR SENSITIVITY USING THE PRIOR SENSE PACKAGE
  
## 1. Sensitivity check
First, check the sensitivity of the prior and likelihood to power-scaling. 
Posterior and posteriors resulting from power-scaling.
```{r}
powerscale_sensitivity(model, variable = c("b_Intercept", "b_breedckcs", "b_breedother", "b_breedpug", "b_breedret"), , facet_rows = "variable")
```

## 2. Kernel density
```{r}
powerscale_plot_dens(model, variable = c("b_Intercept", "b_breedckcs", "b_breedother", "b_breedpug", "b_breedret"), facet_rows = "variable")
```


# 3. Now use bayestestR package to check priors are informative
```{r}
check_prior(model, effects = "all")
```







# CHECK PRIOR PREDICTIVE DISTRIBUTION

# 1. Prior Predictive Distribution
Can simulate data just on the priors.  Fit model but only consider prior when fitting model.
If this looks reasonable, it helps to confirm that your priors were reasonable
```{r}
set.seed(666)
model_priors_only <- brm(slgCort ~ breed +  (1 | visit),
                   family = skew_normal(),
                   prior = priors,
                   data = df,
                   sample_prior = "only")
```


# 2. Check predictions against priors
```{r}
pp_check(model_priors_only, ndraws = 100) +
  xlim(c(-10, 10))
```





# VARIANCE-COVARIANCE MATRIX

```{r}
as_draws_df(model) %>%
  select(b_Intercept:sigma) %>%
  cov() %>%
  round(digits = 3)
```



# MANUAL POSTERIOR PREDICTIVE DISTRIBUTION CHECKS
NB Uses posterior_predict

## 1. Posterior predictive distribution plots for breed
```{r}
# use posterior predict to simulate predictions
ppd <- posterior_predict(model) 

par(mfrow = c(2,2))
stripchart(slgCort ~ breed, vertical = TRUE, method = "jitter",
           col = "steelblue3", data = df, pch = 20, main = "Observed")
stripchart(ppd[sample(seq(1, dim(ppd)[1]), 1),] ~ breed, vertical = TRUE, method = "jitter",
           col = "firebrick3", data = df, pch = 20, main = "PPD")
stripchart(ppd[sample(seq(1, dim(ppd)[1]), 1),] ~ breed, vertical = TRUE, method = "jitter",
           col = "firebrick3", data = df, pch = 20, main = "PPD")
stripchart(ppd[sample(seq(1, dim(ppd)[1]), 1),] ~ breed, vertical = TRUE, method = "jitter",
           col = "firebrick3", data = df, pch = 20, main = "PPD")
```






# ANALYSING THE POSTERIOR DISTRIBUTION

# 1a. Plot conditional effects from model
```{r}
plot(conditional_effects(model), ask = FALSE)
```


### 1b. advanced plot of conditional effect of breed
```{r}
ce <- conditional_effects(model, effects = "breed", prob = 0.95)
ce_df <- ce[[1]][c(1, 6:9)]

ggplot(ce_df, aes(x=breed, y=estimate__, group=1)) +
    geom_errorbar(width=.1, aes(ymin=lower__, ymax=upper__), colour=c("#F8766D", "#A3A500","#00BF7D",
                                                                      "#00B0F6", "#E776F3"), linewidth = 1) +
    geom_point(shape=21, size=6, fill=c("#F8766D", "#A3A500","#00BF7D",
                                        "#00B0F6", "#E776F3")) +
   theme_bw() +
    labs(title = "Conditional effect of breed on hair cortisol") +
         labs(y = paste0("Log Hair Cortisol (standardised)")) +
         labs(x = paste0("breed")) +
         theme(axis.title.y = element_text(size=12, face="bold"), 
               axis.title.x = element_text(size=12, face="bold"),
               title = element_text(size=12, face="bold"),
               plot.title = element_text(hjust = 0.5),
               axis.text.x = element_text(color = "grey25", size = 12),
               axis.text.y = element_text(color = "grey50", size = 10))
```




# 2. mcmc_plot of model
## a.just parameters of beta variables
```{r}
mcmc_plot(model,
          variable = c(
         "b_breedckcs",
         "b_breedpug",
         "b_breedret",
         "b_breedother"))
```





## b. all parameters except alpha and sd_visit_intercept
```{r}
mcmc_plot(model, variable = c(
         "b_Intercept",
         "sigma",
         "b_breedckcs",
         "b_breedpug",
         "b_breedret",
         "b_breedother"))
```


# 3. Plot all posterior distributions
```{r}
posterior <- as.matrix(model)
mcmc_areas(posterior,
pars = c("b_Intercept", "sigma",
         "b_breedckcs",
         "b_breedpug",
         "b_breedret",
         "b_breedother"),
# arbitrary threshold for shading probability mass
prob = 0.75)
```


## 4. plot posterior distribution for breeds vs priors
```{r}
posterior <- as.matrix(model)
mcmc_areas(posterior,
    pars = c("b_breedckcs",
         "b_breedpug",
         "b_breedret",
         "b_breedother",
         "prior_b"),
    prob = 0.75) + # arbitrary threshold for shading probability mass 

   theme_classic() +
    labs(title = "Prior vs posterior distribution for breed") +
         labs(y = "") +
         labs(x = paste0("Possible parameter values")) +
    scale_y_discrete(labels=c("prior_b" = "Breed prior",
                              "b_breedother" = "Other posterior",
                              "b_breedret" = "Retriever posterior",
                              "b_breedpug" = "Pug posterior",
                              "b_breedckcs" = "CKCS posterior"),
                   limits = c("prior_b", "b_breedother",
                              "b_breedret", "b_breedpug",
                              "b_breedckcs")) +
         theme(axis.title.y = element_text(size=12, face="bold"), 
               axis.title.x = element_text(size=12, face="bold"),
               title = element_text(size=12, face="bold"),
               plot.title = element_text(hjust = 0.5),
               axis.text.x = element_text(color = "grey50", size = 12),
               axis.text.y = element_text(color = "grey8",size = 12))
```






## 5. Describe the posterior visually
```{r}
# Focus on describing posterior
hdi_range <- hdi(model, ci = c(0.65, 0.70, 0.80, 0.89, 0.95))
plot(hdi_range)
```






# HYPOTHESIS TESTS

## 1. mix vs. ckcs (from draws) is >0
```{r}
draws <- as.matrix(model)
mean(draws[,2] >0)
mean(draws[,2] <0)
```

### Check 97% credible interval of with HPDI for mix vs. ckcs from draws 
```{r}
HPDI(draws[,2], prob=0.97)
```


## 2. mix vs. pug (from draws) is >0
```{r}
draws <- as.matrix(model)
mean(draws[,3] >0)
mean(draws[,3] <0)
```

### Check 97% credible interval of with HPDI for mix vs. pug from draws 
```{r}
HPDI(draws[,3], prob=0.97)
```


## 2. mix vs. ret (from draws) is >0
```{r}
draws <- as.matrix(model)
mean(draws[, 4] >0)
mean(draws[, 4] <0)
```

### Check 97% credible interval of with HPDI for mix vs. ret from draws 
```{r}
HPDI(draws[, 4], prob=0.97)
```


## 3. mix vs. other (from draws) is >0
```{r}
draws <- as.matrix(model)
mean(draws[, 5] >0)
mean(draws[, 5] <0)
```

### Check 97% credible interval of with HPDI for mix vs. other from draws 
```{r}
HPDI(draws[, 5], prob=0.97)
```





## 3. Visualising the posterior of a model using numerical and graphical methods
### a. basic (one dog only)
```{r}
# create new dataframe which contains results of the first dog
new_data <- rbind(df[1,], df[1,], df[1,], df[1,], df[1,])
# Now change one category to be different
new_data$breed <- c("mix", "ckcs", "pug", "ret", "other")
# Visualise df to make sure it has worked
new_data

# Now get mean predictions from the draws of the model
pred_means <- posterior_predict(model, newdata = new_data)


# Compare difference in means for each breedversus mix
differenceCKCS <- pred_means[,1] - pred_means[,2]
differencePug <- pred_means[,1] - pred_means[,3]
differenceRet <- pred_means[,1] - pred_means[,4]
differenceOther <- pred_means[,1] - pred_means[,5]

par(mfrow = c(2,2))

# Examine mean of difference
mean(differenceCKCS)
# View histogram of this
hist(differenceCKCS)
# Create HPDI
HPDI(differenceCKCS, 0.93)

# Examine mean of difference
mean(differencePug)
# View histogram of this
hist(differencePug)
# Create HPDI
HPDI(differencePug, 0.93)

# Examine mean of difference
mean(differenceRet)
# View histogram of this
hist(differenceRet)
# Create HPDI
HPDI(differenceRet, 0.93)

# Examine mean of difference
mean(differenceOther)
# View histogram of this
hist(differenceOther)
# Create HPDI
HPDI(differenceOther, 0.93)

```


### b. Advanced... using all dogs in the model
#### i. ckcs vs mix
```{r}
# create new dataframe which contains results of all dogs
new_data1 <- df
# Now change one category to be different
new_data1$breed_group <- c("mix")

# create new dataframe which contains result sof all dogs
new_data2 <- df
# Now change one category to be different
new_data2$breed_group <- c("ckcs")

# Now get predictions from the draws of the models
pred_nd1 <- posterior_predict(model, newdata = new_data1)
pred_nd2 <- posterior_predict(model, newdata = new_data2)
pred_diff <- pred_nd1 - pred_nd2
pred_diff <- data.frame(pred_diff)

# Create mean of differences for each column (dog) of the dataframe
pred_diff_ckcs <- apply(pred_diff, 2, mean)
# View histogram of mean differences
hist(pred_diff_ckcs)

# Examine mean of difference
mean(pred_diff_ckcs)
# View histogram of this

HPDI(pred_diff_ckcs, 0.97)
```


#### ii. pug vs mix
```{r}
# create new dataframe which contains results of all dogds
new_data2 <- df
# Now change one category to be different
new_data2$breed_group <- c("pug")

# Now get predictions from the draws of the models
pred_nd1 <- posterior_predict(model, newdata = new_data1)
pred_nd2 <- posterior_predict(model, newdata = new_data2)
pred_diff <- pred_nd1 - pred_nd2
pred_diff <- data.frame(pred_diff)

# Create mean of differences for each column (dog) of the dataframe
pred_diff_pug <- apply(pred_diff, 2, mean)
# View histogram of mean differences
hist(pred_diff_pug)

# Examine mean of difference
mean(pred_diff_pug)
# View histogram of this
HPDI(pred_diff_pug, 0.97)
```


#### iii. other vs mix
```{r}
# create new dataframe which contains results of all dogs
new_data2 <- df
# Now change one category to be different
new_data2$breed_group <- c("other")

# Now get predictions from the draws of the models
pred_nd1 <- posterior_predict(model, newdata = new_data1)
pred_nd2 <- posterior_predict(model, newdata = new_data2)
pred_diff <- pred_nd1 - pred_nd2
pred_diff <- data.frame(pred_diff)

# Create mean of differences for each column (dog) of the dataframe
pred_diff_other <- apply(pred_diff, 2, mean)
# View histogram of mean differences
hist(pred_diff_other)

# Examine mean of difference
mean(pred_diff_other)
# Create HPDI
HPDI(pred_diff_other, 0.97)
```


#### iv. ret vs mix
```{r}
# create new dataframe which contains results of all dogs
new_data2 <- df
# Now change one category to be different
new_data2$breed_group <- c("ret")

# Now get predictions from the draws of the models
pred_nd1 <- posterior_predict(model, newdata = new_data1)
pred_nd2 <- posterior_predict(model, newdata = new_data2)
pred_diff <- pred_nd1 - pred_nd2
pred_diff <- data.frame(pred_diff)

# Create mean of differences for each column (dog) of the dataframe
pred_diff_ret <- apply(pred_diff, 2, mean)
# View histogram of mean differences
hist(pred_diff_ret)

# Examine mean of difference
mean(pred_diff_ret)
# Create HPDI
HPDI(pred_diff_ret, 0.97)
```









# Check if better fit if you allow SD to vary arcoss breed

## 1. Set priors2
```{r}
# Set individual priors
prior_int <- set_prior("normal(0, 1)", class = "Intercept")
prior_b <- set_prior("normal(0, 1)", class = "b")
prior_sd <- set_prior("normal(0, 2)", class = "sd")
prior_alpha <- set_prior("normal(4, 2)", class = "alpha")

# Combine priors into list
priors2 <- c(prior_int, prior_b, prior_sd, prior_alpha)
```





## 2. Run model 2
Increased adapt_delta >0.8 (0.9 here), as had divergent transitions
```{r}
set.seed(666)
model2 <- brm(bf(slgCort ~ breed + (1 | visit),
                 sigma ~ breed),
                   family = skew_normal(),
                   prior = priors2,
                   data = df,
                   control=list(adapt_delta=0.9999, stepsize = 0.001, max_treedepth =15),
                   iter = 8000, warmup = 2000,
                   cores = 4,
                   save_pars = save_pars(all =TRUE),
                   sample_prior = TRUE)
```


## 3. get summary of model
```{r}
summary(model2)
```




## 4. Try the PSIS LOO-CV procedure to check model performance
```{r}
loo_model2 <- loo(model2, moment_match = TRUE)
loo_model2
```


## 5. Compare looic for models 1 and 2
```{r}
model <- add_criterion(model, "loo")
model2 <- add_criterion(model2, "loo")
loo_compare(model, model2)
```
Model 1 is a better fit so keep this

